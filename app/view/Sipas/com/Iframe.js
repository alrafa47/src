/*
 * File: app/view/Sipas/com/Iframe.js
 *
 * This file was generated by Sencha Architect version 3.5.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.2.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.2.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('SIPAS.view.Sipas.com.Iframe', {
    extend: 'Ext.Component',
    alias: 'widget.sipas_com_iframe',

    url: 'about:blank',
    loadingText: 'Loading ...',
    maskLoading: true,
    zoomState: 1,

    initComponent: function() {
        var me = this;

        me.addEvents(
            'beforeload',
            'load',
            'zoom',
            'zoomin',
            'zoomout'
        );

        Ext.applyIf(me, {
            autoEl: {
                tag: 'iframe',
                frameborder: '0',
                width: '100%',
                height: '100%',
                src: this.url,
                name: this.name,
                allowfullscreen: true,
                mozallowfullscreen: true,
                webkitallowfullscreen: true
            },
            listeners: {
                afterrender: {
                    fn: me.onAfterRender,
                    scope: me
                }
            }
        });

        me.callParent(arguments);
    },

    onAfterRender: function(component, eOpts) {
        var me = this;
        this.getFrame().onload = function(){
            me.onLoad();
        };
    },

    getWindow: function() {
        var me = this,
            win = me.name ? window.frames[name] : me.el.dom.contentWindow;
        return win;
    },

    getDocument: function() {
        try {
            return this.getWindow().document;
        } catch (ex) {
            return null;
        }
    },

    getBody: function() {
        var doc = this.getDocument();
        return doc.body || doc.documentElement;
    },

    getFrame: function() {
        var me = this;
        if(!me.rendered) return;
        return me.el.dom;
    },

    beforeDestroy: function() {
        this.cleanupListeners(true);
        this.callParent(arguments);
    },

    cleanupListeners: function(destroying) {
        var doc, prop;

        if (this.rendered) {
            try {
                doc = this.getDocument();
                if (doc) {
                    Ext.EventManager.removeAll(doc);
                    if (destroying) {
                        for (prop in doc) {
                            if (doc.hasOwnProperty && doc.hasOwnProperty(prop)) {
                                delete doc[prop];
                            }
                        }
                    }
                }
            } catch(e) { }
        }
    },

    onRelayedEvent: function(event) {
        // relay event from the iframe's document to the document that owns the iframe...

                var iframeEl = this.el,

                    // Get the left-based iframe position
                    iframeXY = Ext.Element.getTrueXY(iframeEl),
                    originalEventXY = event.getXY(),

                    // Get the left-based XY position.
                    // This is because the consumer of the injected event (Ext.EventManager) will
                    // perform its own RTL normalization.
                    eventXY = Ext.EventManager.getPageXY(event.browserEvent);

                // the event from the inner document has XY relative to that document's origin,
                // so adjust it to use the origin of the iframe in the outer document:
                event.xy = [iframeXY[0] + eventXY[0], iframeXY[1] + eventXY[1]];

                event.injectEvent(iframeEl); // blame the iframe for the event...

                event.xy = originalEventXY; // restore the original XY (just for safety)
    },

    load: function(url, callback, scope) {
        var me = this,
            frame = me.getFrame();

        if (me.fireEvent('beforeload', me, url) !== false) {
            if(me.maskLoading) {
                me.rendered && me.setLoading(me.loadingText);
            }

            this.on('load', callback || Ext.emptyFn, scope || this, {single: true});

            me.url = (url || me.url);
            frame && (frame.src = me.url);
        }
        return me;
    },

    reload: function(callback, scope) {
        return this.load(this.url, callback, scope);
    },

    print: function() {
        this.getWindow().print();
        return this;
    },

    zoom: function(value) {
        this.zoomState = value = value || 1.0;
        this.getBody().style.zoom = this.zoomState;
        return this;
    },

    zoomIn: function(value) {
        this.zoomState += value || 0.1;
        this.getBody().style.zoom = this.zoomState;
        return this;
    },

    zoomOut: function(value) {
        this.zoomState -= value || 0.1;
        this.getBody().style.zoom = this.zoomState;
        return this;
    },

    onLoad: function() {
        var me = this,
            doc = me.getDocument(),
            fn = me.onRelayedEvent;

        this.setLoading(false);
        this.fireEvent('load', this, doc);
        return; // force end sub

        if (doc) {
            try {
                Ext.EventManager.removeAll(doc);

                // These events need to be relayed from the inner document (where they stop
                // bubbling) up to the outer document. This has to be done at the DOM level so
                // the event reaches listeners on elements like the document body. The effected
                // mechanisms that depend on this bubbling behavior are listed to the right
                // of the event.
                Ext.EventManager.on(doc, {
                    mousedown: fn, // menu dismisal (MenuManager) and Window onMouseDown (toFront)
                    mousemove: fn, // window resize drag detection
                    mouseup: fn,   // window resize termination
                    click: fn,     // not sure, but just to be safe
                    dblclick: fn,  // not sure again
                    scope: me
                });
            } catch(e) {
                // cannot do this xss
            }

            // We need to be sure we remove all our events from the iframe on unload or we're going to LEAK!
            Ext.EventManager.on(this.getWindow(), 'beforeunload', me.cleanupListeners, me);

            this.setLoading(false);
            this.fireEvent('load', this);

        } else if(me.url && me.url != '') {

            this.setLoading(false);
            this.fireEvent('error', this);
        }
    }

});